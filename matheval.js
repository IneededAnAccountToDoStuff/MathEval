//JS port of MathEval.py

//class SubArray extends Array{last(){return this[this.length-1]}}

class Tuple{#list;toJSON(){return{type:'tuple',data:this.#list}}getlength(){return this.#list.length}[Symbol.iterator](){return this.#list[Symbol.iterator]()}constructor(list){this.#list=Array.from(list);for(let prop of Object.getOwnPropertyNames(Array.prototype)){if(prop!='constructor'){this[prop]=function(){return this.#list[prop](...arguments)}}}}}function tuple(list){return new Tuple(list)}
function pow(a,b,c=null){if(c!=null){let r=1;while(b>0){r=(r*a)%c;b--}return r}else{return a**b}}
let _base_funcs={'pow':pow,'getthree':()=>3,'abs':Math.abs,'ʒ':x=>0*x,'iseven':x=>0==x%2,'nthroot':(y,x)=>[['^',x,['/',1,y]]],'√':(x,y)=>[['^',x,['/',1,y]]],'int':Math.trunc,'sqrt':a=>['^',a,['/',1,2]]};let _base_conts={'pi':Math.PI,'one':1,'⊥':false,'⊤':true,'∞':Infinity}
//NOTE: complex numbers are not default existing in JS, so that's missing
function* enumerate(list,s=0){yield* Array.from(list).map((a,i)=>[i+s,a])}
function *zip(...i){i=i.map(i=>i[Symbol.iterator]());while(1){let r=i.map(i=>i.next());if(r.some(r=>r.done)){return}else{yield r.map(r=>r.value)}}}
function *range(start,stop=null,step=1){if(stop==null){stop=start;start=0}while(step*start<step*stop){yield start;start+=step}}
function isstring(i){return i instanceof String||typeof i==="string"}
let islist=Array.isArray
function arraycount(arr,val){return arr.reduce((a,i)=>a+(i===val),0)}
function chainedcompare(a,b,c,d1r=false,d2r=false,eqs=[0,0]){return((eqs[0]&&a==b)||(d1r?a>b:a<b))&&((eqs[1]&&a==b)||(d2r?b>c:b<c))}
function isnumber(a){return typeof a==='number'||a instanceof Number||a===true||a===false}
function sum(a){return a.reduce((a,i)=>a+i)}
function implicit_multiplication_handler(string){return string.replaceAll(/([0-9]+)([^0-9+^%!+‼¬*{}/≥≤≠,=><()⌊⌋⌈⌉-]+)/g,'($1*$2)').replaceAll(/([0-9)])\(/g,'$1*(').replaceAll(/\)([^+^%!+‼¬*{}/≥≤≠,=><()⌊⌋⌈⌉-]+)/g,')*$1')}
function _tokenize(string,processor_settings=def_processor_settings){string.replaceAll(' ','').replaceAll('**','^').replaceAll('⋅','*').replaceAll('!=','≠').replaceAll('÷','/').replaceAll('>=','≥').replaceAll('<=','≤').replaceAll('mod','%').replaceAll('‼','!!');while(string.includes`--`){string=string.replaceAll('--','+')}while(string.includes`++`){string=string.replaceAll('++','+')}while(string.includes`+-`){string=string.replaceAll('+-','-')}while(string.includes`-+`){string=string.replaceAll('-+','-')}if(processor_settings.implicit_multiplication_handler){string=implicit_multiplication_handler(string)}if(processor_settings.multifactorial){while(string.includes`!!`){let b=string.indexOf`!!`;let a=b;while(b!=string.length&&'!'===string[b]){b++}string=`${string.slice(0,a)}‼${b-a}${string.slice(b)}`}}let par_expr=[];let j=0;let operators=[[-1,[['^','^'],1,-1]],[1,[['%','percent'],['!','!'],-1,1.1]],[1,[['‼','‼'],1,-1]],[1,[['+','pos'],['-','neg'],1,-1.1]],[1,[['!','derange'],['¬','¬'],1,-1.1]],[1,[['*','*'],['/','/'],['%','mod'],1,-1]],[1,[['+','+'],['-','-'],1,-1]],[1,[['≥','≥'],['≤','≤'],['≠','≠'],['=','='],['>','>'],['<','<'],1,-1]],];let brackets=[['()',null],['⌊⌋','floor'],['⌈⌉','ceil']];{let _=processor_settings.braces_fractional;if(_){brackets.push(['{}',_==1?'fractional':null])}}let r_oper=new Set([...operators.map(a=>a[1]).flat().filter(a=>typeof(a)!="number").map(a=>a[0]),',']);let funcbreakers=new Set([...r_oper,...brackets.map(a=>a[0]).flat().join``]);let funccatch={};let s_br=new Set([...brackets.map(a=>a[0][0])]);let e_br=new Set([...brackets.map(a=>a[0][1])]);let s_brd=Object.fromEntries(brackets.map(a=>[a[0][0],tuple([a[0][1],a[1]])]));let nodes={null:[string]};let current=[null];let func;let c=0;while(current.length){let a=current.pop();string=nodes[a][0];let pairend=null;let pairstart=null;if(string instanceof Tuple){[func,string]=string}else{func=null}let matches=[];let level=0;let foundfunc=null;let res=[];let cur=[];let brfu=null;for(let[i,v]of enumerate(string)){if(pairstart===null){if(s_br.has(v)){pairstart=v;if(i>0){i-=1;c=0;while(!funcbreakers.has(string[i])&&i>=0){i-=1;c+=1}i+=1}else{c=0}cur=c?cur.slice(0,-c):cur;matches.push([c,i]);let _=s_brd[pairstart];pairend=_.at(0);foundfunc=_.at(1);if(c&&foundfunc!==null){throw new SyntaxError(`Bracket ${v} doesn't support functions`)}res.push(cur.join``);cur.length=0}else{if(e_br.has(v)){throw new SyntaxError(`Bracket End ${v} missing Start Symbol`)}else{cur.push(v)}}}else{if(v==pairstart){level+=1}else{if(v==pairend){if(level){level-=1}else{matches[matches.length-1]=tuple([...matches.at(-1),i+1,foundfunc]);pairend=pairstart=null}}}}}res.push(cur.join``);if(matches.length&&2==(matches.at(-1).length)){throw new SyntaxError(`Bracket ${pairstart} at ${matches.at(-1)[1]} was never closed`)}let d=[];matches=matches.map(a=>[...a]).map(([c,i,v,d])=>[c?tuple([string.slice(i,i+c),string.slice(i+c+1,v-1)]):(d==null?string.slice(i+1,v-1):tuple([d,string.slice(i+1,v-1)]))]);for(let[l,i]of enumerate(matches)){if(i[0]in nodes){matches[l]=nodes[i[0]]}else{nodes[i[0]]=i;current.push(i[0])}}for(let[i,v]of zip(res,matches)){d.push(i,v)}if(res.length>matches.length){d.push(res.at(-1))}d=d.filter(i=>i!='');c=[];for(let i of d){if(isstring(i)){let cc=[];for(let j of i){if(r_oper.has(j)){c.push(cc.join``,j);cc.length=0}else{cc.push(j)}}c.push(cc.join``)}else{c.push(i)}}let x=c.filter(i=>i!='');let opmap;for(let[_dir,...op]of operators){opmap=Object.fromEntries(op.map(i=>i.filter(ii=>islist(ii)).map(ii=>[ii[0],ii[1]!==null?ii[1]:ii[0]])).flat());op=op.map(i=>tuple(i.map(ii=>islist(ii)?ii[0]:ii))).filter(i=>i.some(ii=>x.includes(ii)));if(op.length==0){continue}let looper=_dir==1?range(x.length):range(x.length-1,-1,-1);let opdict=Object.fromEntries(op.map(i=>[tuple(i.filter(isstring)),new Set(i.filter(isnumber))]));let opp=Object.keys(opdict);let ops=opp.map(i=>Array.from(i)).flat().filter(i=>i!=',');let v=1;while(v){for(let index of looper){v=0;if(ops.includes(x[index])){let j=opp.filter(i=>i.includes(x[index]))[0];let para=opdict[j];let c=[];let exc=[...para].filter(i=>!Number.isInteger(i)).map(Math.trunc);para=[...para].filter(Number.isInteger);for(let iii of para){if(!chainedcompare(0,index+iii,x.length,0,0,[1,0])||(r_oper.has(x[index+iii]))){c=0;break}c.push(x[index+iii])}for(let iii of exc){if(chainedcompare(0,index+iii,x.length,0,0,[1,0])&&((islist(x[index+iii])||x[index+iii]instanceof Tuple)||!r_oper.has(x[index+iii]))){c=0;break}}if(c.length){c.reverse();x[index]=[opmap[x[index]],...c];let _=[...para];_.sort((a,b)=>b-a);for(let iii of _){x.splice(index+iii,1)}looper=_dir==1?range(x.length):range(x.length-1,-1,-1);v=1}}if(v){break}}}}d=x.filter(i=>''!==i).map(i=>islist(i)&&islist(i[0])&&1==i.length?i[0]:i);if(!d.length&&func===null){throw new SyntaxError('An empty statement is invalid')}if(d.every(i=>!islist(i)&&r_oper.has(i))&&func===null){throw new SyntaxError("No numbers - just operators")}if(d.length>1){if(func===null){throw new SyntaxError("Probably missing an operator")}else{let pcount=arraycount(d,',');d=d.filter(i=>','!=i);if(pcount+1!=d.length){throw new SyntaxError('Error: Missing operator/comma')}}}nodes[a][0]=func===null?d:tuple([func,d])}nodes=nodes[null];while(1==nodes.length&&nodes[0]instanceof Array){nodes=nodes[0]}return nodes}
//def _untokenize(tokens)->str:pass
function factorial(a){return Array(Number(a)).fill().map((_,i)=>(i)+1).reduce((a,i)=>a*i,1)}
function nfactorial(a,b){let q=1;for(let i of range(a,1,-b)){q*=i}return q}
_base_funcs.nfact=nfactorial

function _mathify(ans,f=0){
  let v;
  if(f){alert('Error accessing deep math engine')}
  else{if(isNaN(ans)){throw new EvalError(`Could not parse "${ans}" as a number.`)}else{return(isnumber(ans)||!ans.includes('.'))?Number(ans):Number(ans)}}
}

let def_processor_settings={multifactorial:false,implicit_multiplication_handler:false,braces_fractional:true}

function _evaluate(tokens,f=0,funcs=_base_funcs,constants=_base_conts){funcs['ceil']=Math.ceil;funcs['floor']=Math.floor;funcs['fractional']=x=>['mod',x,1];let cil=tokens.length;let layers=[tokens];function getval(a){return a in constants?constants[a]:_mathify(a,f)}function numericyesno(a){while((islist(a)||a instanceof Tuple)&&1==(a.getlength?.()??a.length)){a=a.at(0)}return islist(a)?null:a}function duo(a){if(a.length!=2){throw new SyntaxError('Parsing Error - more than two parameters for binary operator')}}function funchand(a){let[f,p]=a[0];c=p.map(numericyesno).map(i=>isstring(i)?getval(i):i);if(c.every(i=>i!=null&&!(i instanceof Tuple))){if(f in funcs){a[0]=funcs[f](...c)}else{throw new EvalError(`Function ${f} not defined`)}}else{let d=['fpar',...p];layers.push(d)}}let c;while(layers.length){let curlay=layers.at(-1);if(curlay.length==1){let d=numericyesno(curlay[0]);if(d==null){layers.push(curlay[0]);continue}else{if(d instanceof Tuple){curlay[0]=c=[d];funchand(c)}else{curlay[0]=tuple([getval(d)]);layers.pop()}}}else{if('fpar'==curlay[0]){let _flag=0;for(let[l,i]of enumerate(curlay.slice(1),1)){let d=numericyesno(i);if(d===null){d=[i];curlay[l]=d;layers.push(d);_flag=1;break}else{if(d instanceof Tuple){funchand(i);_flag=1;break}}}if(!_flag){layers.pop()}}else{let[op,...b]=curlay;let trip=0;for(let[v,a]of enumerate(b)){if(isstring(a)){b[v]=getval(a)}else{if(islist(a)){if(a[0]instanceof Tuple){if(a[0].getlength()==1){b[v]=a[0].at(0)}else{let d=curlay[v+1]=[a[0]];funchand(d);trip=1;break}}else{layers.push(a);trip=1;break}}}}if(trip){continue}let res;switch(op){case'+':{res=sum(b);break}case'*':{duo(b);res=b[0]*b[1];break}case'-':{duo(b);res=b[0]-b[1];break}case'^':{duo(b);res=b[0]**b[1];break}case'/':{duo(b);res=b[0]/b[1];break}case'≥':{res=b.every(ii=>b[0]>=ii);break}case'≤':{res=b.every(ii=>b[0]<=ii);break}case'≠':{res=b.slice(1).every(ii=>b[0]!=ii);break}case'=':{res=b.every(ii=>b[0]==ii);break}case'>':{res=b.slice(1).every(ii=>b[0]>ii);break}case'<':{res=b.slice(1).every(ii=>b[0]<ii);break}case'neg':{if(b.length==1){res=-b[0]}else{throw new SyntaxError("Honestly, I don't know how you tricked by program into recognising multiple parameters for negation. Something has gone horribly wrong - please file a bug request")};break}case'pos':{if(b.length==1){res=b[0]}else{throw new SyntaxError("Honestly, I don't know how you tricked by program into recognising multiple parameters for positivation. Something has gone horribly wrong - please file a bug request")};break}case'¬':{if(b.length==1){res=!b[0]}else{throw new SyntaxError("Honestly, I don't know how you tricked by program into recognising multiple parameters for ¬. Something has gone horribly wrong - please file a bug request")};break}case'‼':{duo(b);res=nfactorial(b[0],b[1]);break}case'!':{if(b.length==1){res=factorial(b[0])}else{throw new SyntaxError("Honestly, I don't know how you tricked by program into recognising multiple parameters for factorial. Something has gone horribly wrong - please file a bug request")};break}case'mod':{duo(b);res=b[0]%b[1];break}case'derange':{if(b.length=1){let n=b[0];let c=1;let x=[1];for(let I of range(1,n+1)){x.push(c=c*I)}b=x.at(-1);res=sum([...enumerate(x)].map(([i,v])=>Math.floor(b/(v*(-1)**i))))}else{throw new SyntaxError(`Program id'd operator as "derangement", but found multiple parameters. Please file a bug request`)};break}case'percent':{if(b.length=1){res=b[0]/100}else{throw new SyntaxError("Probably modulo misidentified as percent. Please file a bug request")};break}default:throw new SyntaxError(`Operator "${op}" not recognized`)}curlay.length=0;curlay.push(res)}}}return tokens[0].at(0)}
function calculate(expression,precise=false,funcs=_base_funcs,constants=_base_conts,processor_settings=def_processor_settings){return _evaluate(_tokenize(expression,processor_settings),precise,funcs,constants)}
function calc_proc(expression,precise=false,funcs=_base_funcs,constants=_base_conts,processor_settings=def_processor_settings){let v=_tokenize(expression,processor_settings);console.log(v);v=_evaluate(v,precise,funcs,constants);console.log(v);return v}
function calc_disp(expression,precise=false,funcs=_base_funcs,constants=_base_conts,processor_settings=def_processor_settings){console.log(expression,'=',_evaluate(_tokenize(expression,processor_settings),precise,funcs,constants))}

let examples={'1+2+3+4':10,'8/4':2,'1+2+3+4/(3+1)':7,'3/(4-1)+3/(3)':2,'(3)':3,'((2))':2,'(3+2)':5,'2%':2/100,'⌊2⌋':2,"⌊2.5⌋":2,'⌈2⌉':2,"⌈2.5⌉":3,'pi':3,'∞+2':Infinity,'∞':Infinity,'-2':-2,'-∞':-Infinity,'(pi)':3,'abs(-4+0)-abs(4)':0,'abs(4)':4,'abs(-4)':4,'((5))':5,'12+4':16,'12*(3-(1+1)+4)':60,'12+4.5':16.5,'!5':44,'5++2':7,'5--2':7,'5+-2':3,'5-+2':3,'12/4':3.0,'5/3':5/3,'3^2^3':6561,'5!':120,'5-4':1,'3.4':3.4,'100%7':100%7,'nthroot(4,6561)':9.0,'abs(4-abs(3+2))':1,'4=4':true,'1=2':false,'1>2':false,'1<2':true,'2≥2':true,'2≤2':true,'2>2':false,'2<2':false,'2≠2':false,'2≠3':true,['3+'.repeat(10)+'3']:33,['3+'.repeat(100)+'3']:303,['3+'.repeat(200)+'3']:603,['3+'.repeat(141)+'3']:426,['3+'.repeat(1000)+'3']:3003,['3*'.repeat(30)+'3']:617673396283947,['abs('.repeat(100)+'3'+')'.repeat(100)]:3,'(((((((((((((((((((((3)))))))))))))))))))))':3,'12*(3-(1+(3-2*(1^1)+0*(2+2)))+4)':60,"abs(4)+pi":7,"abs(pi)":3,"¬1":0,"¬0":1,"nthroot(1+1,64)":8}
function unittest(){
for(let[i,v]of Object.entries(examples)){
//console.clear()
console.log(`Init: ${i.slice(0,100)}`);if(i.length==2001){console.log('skip');continue}let b=calculate(i);console.log(`Result: ${b}, ${b==v}\n\n`)
}
console.log('Note: MathEval uses floating-point numbers, so radicals and other numbers may be off. Also this is the JS port, it is slower (for some reason. Also, the file size is smaller).')
}

function clonetokens(tokens){function helper(_,v,z){if(typeof v==='object'&&v.type==='tuple'){v=tuple(v.data)}return v}return JSON.parse(JSON.stringify(tokens),helper)}
